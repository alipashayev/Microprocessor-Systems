#define F_CPU 16000000UL
#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>

#define SLAVE_ADDRESS 0x08

volatile uint8_t received_data = 0;
volatile uint8_t data_to_send = 0;
volatile uint8_t data_ready = 0;

void i2c_slave_init(uint8_t address) {
    TWAR = (address << 1);
    TWCR = (1 << TWEN) | (1 << TWEA) | (1 << TWIE);
}

ISR(TWI_vect) {
    uint8_t status = TWSR & 0xF8;
    
    switch (status) {
        
        case 0x60: 
        case 0x70:  
            TWCR = (1 << TWEN) | (1 << TWEA) | (1 << TWIE) | (1 << TWINT);
            break;
            
        case 0x80:  
        case 0x90: 
            received_data = TWDR;
            data_to_send = received_data;
            data_ready = 1;
            TWCR = (1 << TWEN) | (1 << TWEA) | (1 << TWIE) | (1 << TWINT);
            break;
            
        case 0x88:  
        case 0x98:
            TWCR = (1 << TWEN) | (1 << TWEA) | (1 << TWIE) | (1 << TWINT);
            break;
            
        
        case 0xA8:  
            TWDR = data_to_send;
            TWCR = (1 << TWEN) | (1 << TWEA) | (1 << TWIE) | (1 << TWINT);
            break;
            
        case 0xB8:  
            TWDR = data_to_send;
            TWCR = (1 << TWEN) | (1 << TWEA) | (1 << TWIE) | (1 << TWINT);
            break;
            
        case 0xC0:  
        case 0xC8:  
            TWCR = (1 << TWEN) | (1 << TWEA) | (1 << TWIE) | (1 << TWINT);
            break;
            
        
        case 0xA0:  
            TWCR = (1 << TWEN) | (1 << TWEA) | (1 << TWIE) | (1 << TWINT);
            break;
            
        case 0x00:  
            TWCR = (1 << TWSTO) | (1 << TWEN) | (1 << TWEA) | (1 << TWIE) | (1 << TWINT);
            break;
            
        default:
            TWCR = (1 << TWEN) | (1 << TWEA) | (1 << TWIE) | (1 << TWINT);
            break;
    }
}

void led_init() {
    DDRD |= (1 << PD5);  
    PORTD &= ~(1 << PD5); 
}

void led_toggle() {
    PORTD ^= (1 << PD5);
}

int main(void) {
    led_init();
    i2c_slave_init(SLAVE_ADDRESS);
    
    sei(); 
    
    _delay_ms(100);
    
    for (uint8_t i = 0; i < 3; i++) {
        PORTD |= (1 << PD5);
        _delay_ms(200);
        PORTD &= ~(1 << PD5);
        _delay_ms(200);
    }
    
    while (1) {
        if (data_ready) {
            led_toggle();
            _delay_us(10);
            led_toggle();
            data_ready = 0;
        }
    }
    
    return 0;
}


    
